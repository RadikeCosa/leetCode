# Conceptos y Patrones - Binary Search Study Plan

## Introducci√≥n

Este documento recopila los conceptos, patrones algor√≠tmicos y t√©cnicas aprendidas durante la resoluci√≥n del **Binary Search Study Plan** de LeetCode. Se construye incrementalmente bas√°ndose en los problemas realmente resueltos.

---

## üéØ **Template Fundamental - B√∫squeda Exacta**

_Aprendido en: Binary Search (704)_

### Patr√≥n Base

```typescript
function binarySearchExact(arr: number[], target: number): number {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```

### Decisiones Clave Validadas

#### ‚úÖ **Condici√≥n del bucle: `left <= right`**

- **Por qu√©**: Permite revisar casos de un solo elemento (`left = right`)
- **Ventaja**: M√°s intuitivo para b√∫squedas exactas
- **Cu√°ndo usar**: Cuando buscas un elemento espec√≠fico

#### ‚úÖ **Inicializaci√≥n: `right = arr.length - 1`**

- **Por qu√©**: Trabajamos con √≠ndices v√°lidos
- **Ventaja**: Consistente con la condici√≥n `<=`
- **Evita**: Accesos fuera de rango

#### ‚úÖ **Actualizaci√≥n: `left = mid + 1`, `right = mid - 1`**

- **Por qu√©**: Elimina el elemento ya revisado (`mid`)
- **Garantiza**: Progreso en cada iteraci√≥n (rango se reduce)
- **Evita**: Bucles infinitos

#### ‚úÖ **C√°lculo seguro: `left + (right - left) / 2`**

- **Por qu√©**: Previene overflow en n√∫meros grandes
- **Matem√°ticamente**: Equivalente a `(left + right) / 2`
- **Buena pr√°ctica**: Adoptarla siempre

---

## üßÆ **An√°lisis de Complejidad**

_Validado en: Binary Search (704)_

### Temporal: O(log n)

- **Raz√≥n**: Cada iteraci√≥n elimina exactamente la mitad del espacio de b√∫squeda
- **Progresi√≥n**: n ‚Üí n/2 ‚Üí n/4 ‚Üí n/8 ‚Üí ... ‚Üí 1
- **Ejemplo pr√°ctico**: Array de 1M elementos = ~20 comparaciones m√°ximo

### Espacial: O(1)

- **Raz√≥n**: Solo usamos 3 variables adicionales (`left`, `right`, `mid`)
- **Constante**: No importa el tama√±o del array

---

## üé™ **Casos Edge Cr√≠ticos**

_Identificados en: Binary Search (704)_

### 1. **Array de un solo elemento**

```typescript
nums = [1], target = 0 ‚Üí -1
nums = [1], target = 1 ‚Üí 0
```

**Ense√±anza**: Verifica que `left <= right` funciona cuando `left = right`

### 2. **Target en extremos**

```typescript
// Primera posici√≥n
nums = [1,2,3,4,5], target = 1 ‚Üí 0

// √öltima posici√≥n
nums = [1,2,3,4,5], target = 5 ‚Üí 4
```

**Ense√±anza**: El algoritmo no se "salta" los boundary conditions

### 3. **Target no existe**

```typescript
nums = [-1,0,3,5,9,12], target = 2 ‚Üí -1
```

**Ense√±anza**: Cuando `left > right`, el elemento no existe

---

## üîß **Invariantes del Algoritmo**

_Comprobadas en: Binary Search (704)_

### Invariante Principal

> **"Si el target existe en el array, debe estar en el rango [left, right]"**

**Mantenimiento:**

1. **Inicializaci√≥n**: `[0, length-1]` contiene todo el array
2. **Iteraci√≥n**: Eliminamos la mitad que no puede contener el target
3. **Terminaci√≥n**: Cuando `left > right`, target no existe

### Progreso Garantizado

> **"En cada iteraci√≥n, el rango [left, right] se reduce estrictamente"**

**Demostraci√≥n:**

- `nums[mid] < target` ‚Üí nuevo rango `[mid+1, right]` (m√°s peque√±o)
- `nums[mid] > target` ‚Üí nuevo rango `[left, mid-1]` (m√°s peque√±o)

---

## üö® **Errores Comunes Evitados**

_Lecciones de: Binary Search (704)_

### 1. **Condici√≥n de bucle incorrecta**

```typescript
// ‚ùå MAL: No revisa √∫ltimo elemento
while (left < right) { ... }

// ‚úÖ BIEN: Revisa todos los elementos
while (left <= right) { ... }
```

### 2. **Actualizaci√≥n sin progreso**

```typescript
// ‚ùå MAL: Posible bucle infinito
left = mid; // o  right = mid;

// ‚úÖ BIEN: Siempre progresa
left = mid + 1;
right = mid - 1;
```

### 3. **Overflow en c√°lculo de mid**

```typescript
// ‚ùå PELIGROSO: Puede desbordarse
mid = (left + right) / 2;

// ‚úÖ SEGURO: Previene overflow
mid = left + (right - left) / 2;
```

---

## üìä **Progreso del Study Plan**

### ‚úÖ **Problemas Completados**

1. **Binary Search (704)** - ‚≠ê FUNDACIONAL

   - Estableci√≥ el template base
   - Valid√≥ decisiones de implementaci√≥n
   - Identific√≥ casos edge cr√≠ticos

2. **Search Insert Position (35)** - üîÑ VARIACI√ìN DEL TEMPLATE
   - Confirm√≥ robustez del template base
   - Introdujo patr√≥n "Lower Bound"
   - Demostr√≥ versatilidad de `return left`

### üéØ **Patr√≥n Lower Bound (Insert Position)**

_Aprendido en: Search Insert Position (35)_

```typescript
function searchInsert(nums: number[], target: number): number {
  let left = 0;
  let right = nums.length - 1;

  while (left <= right) {
    const mid = Math.floor(left + (right - left) / 2);

    if (nums[mid] === target) {
      return mid; // Caso exacto - mismo que template base
    } else if (nums[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return left; // üîë CLAVE: Posici√≥n de inserci√≥n
}
```

#### ‚úÖ **Insight Fundamental**

**¬øPor qu√© `return left` funciona para inserci√≥n?**

- Cuando el loop termina (`left > right`), `left` apunta a:
  - El primer elemento mayor que target, OR
  - El final del array (si target > todos los elementos)
- Esta es **exactamente** la posici√≥n donde target deber√≠a insertarse

#### ‚úÖ **Comparaci√≥n de Templates**

| Aspecto                    | Binary Search (704)                 | Search Insert Position (35)         |
| -------------------------- | ----------------------------------- | ----------------------------------- |
| **Inicializaci√≥n**         | `left=0, right=len-1`               | `left=0, right=len-1`               |
| **Condici√≥n loop**         | `left <= right`                     | `left <= right`                     |
| **Mid calculation**        | `Math.floor(left + (right-left)/2)` | `Math.floor(left + (right-left)/2)` |
| **Pointer updates**        | `left=mid+1, right=mid-1`           | `left=mid+1, right=mid-1`           |
| **Elemento encontrado**    | `return mid`                        | `return mid`                        |
| **Elemento NO encontrado** | `return -1`                         | `return left`                       |

**Conclusi√≥n**: El template es **id√©ntico** excepto por el valor de retorno cuando no se encuentra el target.

### üîÑ **Pr√≥ximos Conceptos a Explorar**

- Find First/Last Occurrence: ¬øC√≥mo modificar para duplicados?
- Rotated Arrays: ¬øC√≥mo adaptar el template?
- Upper Bound: ¬øVariaci√≥n del Lower Bound?

---

## üéì **Lecciones Clave Hasta Ahora**

1. **Template `left <= right`** es extremadamente vers√°til
2. **Mismo algoritmo, diferente return**: Una peque√±a modificaci√≥n cambia completamente la funci√≥n
3. **Lower Bound pattern**: `return left` para posici√≥n de inserci√≥n
4. **Robustez del template**: Maneja edge cases autom√°ticamente
5. **Reutilizaci√≥n de c√≥digo**: Patrones similares para problemas diferentes

---

_√öltima actualizaci√≥n: 6 de septiembre de 2025_  
_Problemas completados: 2/42 - Construyendo conocimiento incrementalmente_ üéØ
